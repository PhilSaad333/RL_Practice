Minimal diffs — delta_entropy_approx.py

Ensure you have the helper (you likely already added it for Phase 1):

@@
     def _scale_for_derivative(self, B_total: int, T_total: int) -> float:
         """
         Scale to average **directional derivatives** over the E-batch.
         For per-token mean:  (1 / T_total) * Σ_mb D_v L_mb
         For per-sequence mean: (1 / B_total) * Σ_mb D_v L_mb
         """
         if self.normalize == "per_token":
             return 1.0 / max(T_total, 1)
         elif self.normalize == "per_sequence":
             return 1.0 / max(B_total, 1)
         else:
             return 1.0


In compute_delta_h_approx_jvp, replace the microbatch scaling block and audit:

@@ def compute_delta_h_approx_jvp(...):
-            scale = self._scale_for_average(B_total, T_total, B_mb, T_mb)
-            total_tokens_used += T_mb
-            scale_sum += float(scale)
-            contribs_mb.append(mb_contrib * float(scale))
+            # Derivative averaging (NOT value averaging):
+            scale = self._scale_for_derivative(B_total, T_total)
+            total_tokens_used += T_mb
+            scale_sum += float(scale)
+            contribs_mb.append(mb_contrib * float(scale))
@@
-        if self.logger:
-            self.logger.info(
-                f"[delta-h approx JVP] ⟨∇H, v⟩={out['delta_h_per_lr']:.6e} | "
-                f"B={out['num_sequences']} T={out['num_tokens']} | baseline={self.baseline_kind}"
-            )
-            self.logger.info(
-                f"[dir JVP][audit] scale_sum={scale_sum:.6f} (target≈1.0 for {self.normalize}), "
-                f"total_tokens_used={total_tokens_used} vs pre_count={T_total}"
-            )
+        if self.logger:
+            self.logger.info(
+                f"[delta-h approx JVP] ⟨∇H, v⟩={out['delta_h_per_lr']:.6e} | "
+                f"B={out['num_sequences']} T={out['num_tokens']} | baseline={self.baseline_kind}"
+            )
+            self.logger.info(
+                f"[delta-h approx JVP][audit] deriv_scale={self._scale_for_derivative(B_total, T_total):.6e}, "
+                f"sum_deriv_scales={scale_sum:.6e} "
+                f"(per_token ⇒ ≈ #microbatches/T_total), total_tokens_used={total_tokens_used}, pre_count={T_total}"
+            )
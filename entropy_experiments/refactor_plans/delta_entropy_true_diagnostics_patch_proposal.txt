Summary:
Extend `DeltaEntropyTrue` with richer diagnostics (ESS, clipping fraction, per-sequence weights/entropy contributions, optional symmetric finite difference) so we can quantify bias/variance and log plots without separate passes.

Rationale:
- Current API only returns a scalar ?H_true, forcing ad-hoc instrumentation to inspect SNIS weights or clipping effects.
- Diagnosing variance/bias (ESS sweeps, symmetric finite difference, clipping relaxations) requires consistent data capture at run-time.
- Feeding these diagnostics back to the runner enables automated logging and the plots suggested in suggestions.txt.

Minimal Diffs:
diff --git a/entropy_experiments/delta_entropy_true.py b/entropy_experiments/delta_entropy_true.py
index CCC3333..DDD4444 100644
--- a/entropy_experiments/delta_entropy_true.py
+++ b/entropy_experiments/delta_entropy_true.py
@@
-    def compute_delta_h_true(
-        self,
-        E_batch: Dict[str, Any],
-        v_named: Dict[str, torch.Tensor],
-        eta: float,
-        cfg: Optional[Dict[str, Any]] = None,
-    ) -> float:
-        """
-        Compute ?H_true(?) on the given E-batch using sequence-level SNIS.
-        """
-        ...
+    def compute_delta_h_true(
+        self,
+        E_batch: Dict[str, Any],
+        v_named: Dict[str, torch.Tensor],
+        eta: float,
+        cfg: Optional[Dict[str, Any]] = None,
+        return_diagnostics: bool = False,
+        symmetric_eta: Optional[float] = None,
+        clip_override: Optional[float] = None,
+    ) -> Union[float, Dict[str, Any]]:
+        """Compute ?H_true(?) with optional diagnostics and symmetric finite difference."""
+        cfg = dict(cfg or {})
+        if clip_override is not None:
+            cfg["clip_c"] = clip_override
+        base_stats, H_base_mean = self._ensure_base_cache(
+            E_batch,
+            report_per_token=cfg.get("report_per_token", False),
+        )
+        new_stats = self._score_batch_new(E_batch, v_named, eta)
+        H_new_snis, ess, lw_stats, clip_fraction = self._snis_reduce(
+            base=base_stats,
+            new=new_stats,
+            clip_c=float(cfg.get("clip_c", 10.0)),
+            report_per_token=cfg.get("report_per_token", False),
+            return_clip_fraction=True,
+        )
+        delta = H_new_snis - H_base_mean
+        if not return_diagnostics and symmetric_eta is None:
+            return delta
+        diag = {
+            "delta_h_true": delta,
+            "base_entropy": H_base_mean,
+            "ess": ess,
+            "logw_stats": {
+                "min": lw_stats[0],
+                "median": lw_stats[1],
+                "max": lw_stats[2],
+            },
+            "clip_fraction": clip_fraction,
+            "seq_integrands": new_stats.integrand_seq.tolist(),
+            "seq_weights": self._collect_weights(base=base_stats, new=new_stats, clip_c=float(cfg.get("clip_c", 10.0))),
+            "token_counts": new_stats.T_tokens.tolist(),
+        }
+        if symmetric_eta:
+            diag["symmetric_fd"] = self._symmetric_fd(
+                E_batch=E_batch,
+                v_named=v_named,
+                eta=float(symmetric_eta),
+                cfg=cfg,
+            )
+        return diag
@@
-    def _snis_reduce(
-        self,
-        *,
-        base: _SeqStats,
-        new: _SeqStats,
-        clip_c: float,
-        report_per_token: bool = False,
-    ) -> Tuple[float, float, Tuple[float, float, float]]:
-        """
-        Self-normalized IS at sequence level.
-
-        Returns:
-            (H_new_snis, ESS, (lw_min, lw_med, lw_max))
-        """
-        ...
+    def _snis_reduce(
+        self,
+        *,
+        base: _SeqStats,
+        new: _SeqStats,
+        clip_c: float,
+        report_per_token: bool = False,
+        return_clip_fraction: bool = False,
+    ) -> Tuple[float, float, Tuple[float, float, float], float]:
+        """Self-normalized IS at sequence level; optionally return clipping fraction."""
+        ...
+        clip_fraction = float((np.abs(lw_raw) > clip_c).mean()) if return_clip_fraction and lw_raw.size else 0.0
+        if return_clip_fraction:
+            return H_new, ess, (lw_min, lw_med, lw_max), clip_fraction
+        return H_new, ess, (lw_min, lw_med, lw_max)
+
+    def _collect_weights(...):
+        raise NotImplementedError
+
+    def _symmetric_fd(...):
+        raise NotImplementedError

Implementation Steps:
1. Move baseline caching into `_ensure_base_cache`, extracting helper to avoid duplication when symmetric FD is requested.
2. Teach `_snis_reduce` to optionally return clipping fraction and raw (unclipped) log-weights for downstream diagnostics; provide helper `_collect_weights` to expose normalized weights when `return_diagnostics` is true.
3. Implement `_symmetric_fd` that reuses cached base stats to evaluate +? and -? without resetting caches, yielding `{"eta": ?_sym, "delta_h_plus": ..., "delta_h_minus": ..., "finite_difference": ...}`.
4. Extend `compute_delta_h_true` to accept `return_diagnostics`, `symmetric_eta`, and `clip_override`; return structured dict with per-sequence integrands, weights, ESS, and log-weight stats when requested.
5. Update caller sites (runner + scripts) to request diagnostics when logging is enabled and to propagate `clip_override`/`symmetric_eta` from config toggles.
6. Ensure CPU <-> GPU device handling is preserved for the new helpers to avoid additional GPU allocations.

Config/Flags:
- Add `config['true_delta_h']['diagnostics']` with keys like `return_per_sequence`, `symmetric_eta`, `clip_overrides` (list of clip thresholds to test), `log_histograms`.
- Provide CLI overrides (e.g., `--true-diagnostics`) to enable the heavier payload only when desired.

Validation:
- Unit test: add `tests/entropy_experiments/test_delta_entropy_true.py` covering ESS, clip_fraction, symmetric FD on small toy distributions.
- Colab smoke test: run `python run_entropy_experiments_batch.py --mode full --true-diagnostics` and confirm logs/JSON include ESS, clip stats, and symmetric finite difference.
- Plot check: local notebook should be able to reconstruct ESS vs ?H gaps from saved JSON without rerunning the model.

Rollback:
- Revert `delta_entropy_true.py` to previous API and remove new config keys.
- Update runner/scripts back to scalar-returning interface if diagnostics cause regressions.
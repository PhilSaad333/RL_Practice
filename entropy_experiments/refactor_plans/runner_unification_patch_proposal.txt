Summary:
Refactor `EntropyMeasurements` so a single `run_experiments` entry point handles ?H sweeps, linear/quadratic approximations, and control-variates diagnostics with shared batching and logging. This supports future Colab drivers while keeping artifact persistence in `entropy_experiments/results` unchanged.

Rationale:
- Current split between `run_experiments` and `run_control_variate_analysis` duplicates sampling/update-vector logic and yields divergent outputs, making diagnostics hard to compare.
- A unified path enables toggling (true ?H, linear-only, lin+quad, CV logging) without repeated runs, improves reproducibility, and simplifies orchestration for new scripts.
- Encapsulating plan/options clarifies which diagnostics were computed and makes future extensions (bootstrap, clipping sweeps) composable.

Minimal Diffs:
diff --git a/entropy_experiments/entropy_experiment_runner.py b/entropy_experiments/entropy_experiment_runner.py
index XXXXXXX..YYYYYYY 100644
--- a/entropy_experiments/entropy_experiment_runner.py
+++ b/entropy_experiments/entropy_experiment_runner.py
@@
-from entropy_experiments.delta_entropy_approx import DeltaEntropyApprox
-from entropy_experiments.delta_entropy_true import DeltaEntropyTrue
+from dataclasses import dataclass, field
+from entropy_experiments.delta_entropy_approx import DeltaEntropyApprox
+from entropy_experiments.delta_entropy_true import DeltaEntropyTrue
@@
-class EntropyMeasurements:
-    """
-    Main method is run_mixed_probe, at the end of the class.
-    """
+@dataclass
+class ExperimentPlan:
+    compute_true: bool = True
+    compute_linear: bool = True
+    compute_linquad: bool = False
+    run_control_variates: bool = False
+    capture_per_sequence: bool = False
+    eta_list: Optional[List[float]] = None
+    cv_features: Optional[List[str]] = None
+    diagnostics_level: str = "standard"
+    output_dir: Optional[str] = None
+
+
+class EntropyMeasurements:
+    """Unified orchestrator for entropy-change experiments and diagnostics."""
@@
-    def run_experiments(self) -> Dict[str, Any]:
-        """
-        Unified, single-GPU mixed probe:
-        1) Sample U and E batches via SequenceProcessor (no DDP).
-        2) Compute the update vector v on U (normalized by LR).
-        3) For an eta sweep, evaluate:
-            - Ground-truth ?H_true on E via parameter overrides (IS path).
-            - First-order ?H1 ˜ g·v using the same v = ? v.
-        """
-        ...
+    def run_experiments(
+        self,
+        plan: Optional[ExperimentPlan] = None,
+        **overrides: Any,
+    ) -> Dict[str, Any]:
+        """Run ?H experiments according to `plan`, returning measurements and diagnostics."""
+        plan_resolved = self._resolve_plan(plan, overrides)
+        batches = self._prepare_batches()
+        update = self._compute_update_vector(batches.U)
+        approx = self._maybe_compute_delta_h_approx(batches.E, update, plan_resolved)
+        true = self._maybe_compute_delta_h_true(batches.E, update, plan_resolved, approx)
+        cv = self._maybe_run_control_variates(batches.E, update, plan_resolved, approx)
+        return self._assemble_outputs(plan_resolved, batches, update, approx, true, cv)
+
+    # helper dataclasses for batching and stats live near existing helpers
+    @dataclass
+    class _Batches:
+        E: Dict[str, Any]
+        U: Dict[str, Any]
+        sampling_sec: float
+
+    @dataclass
+    class _UpdateInfo:
+        v_named: Dict[str, torch.Tensor]
+        stats: Dict[str, Any]
+        seconds: float
+
+    def _resolve_plan(self, plan: Optional[ExperimentPlan], overrides: Dict[str, Any]) -> ExperimentPlan:
+        """Merge config defaults, dataclass values, and ad-hoc overrides."""
+        raise NotImplementedError
+
+    def _prepare_batches(self) -> "EntropyMeasurements._Batches":
+        """Shared sampling path for E and U batches."""
+        raise NotImplementedError
+
+    def _compute_update_vector(self, U_batch: Dict[str, Any]) -> "EntropyMeasurements._UpdateInfo":
+        raise NotImplementedError
+
+    def _maybe_compute_delta_h_approx(
+        self,
+        E_batch: Dict[str, Any],
+        update: "EntropyMeasurements._UpdateInfo",
+        plan: ExperimentPlan,
+    ) -> Optional[Dict[str, Any]]:
+        raise NotImplementedError
+
+    def _maybe_compute_delta_h_true(
+        self,
+        E_batch: Dict[str, Any],
+        update: "EntropyMeasurements._UpdateInfo",
+        plan: ExperimentPlan,
+        approx: Optional[Dict[str, Any]],
+    ) -> Optional[Dict[str, Any]]:
+        raise NotImplementedError
+
+    def _maybe_run_control_variates(
+        self,
+        E_batch: Dict[str, Any],
+        update: "EntropyMeasurements._UpdateInfo",
+        plan: ExperimentPlan,
+        approx: Optional[Dict[str, Any]],
+    ) -> Optional[Dict[str, Any]]:
+        raise NotImplementedError
+
+    def _assemble_outputs(
+        self,
+        plan: ExperimentPlan,
+        batches: "EntropyMeasurements._Batches",
+        update: "EntropyMeasurements._UpdateInfo",
+        approx: Optional[Dict[str, Any]],
+        true: Optional[Dict[str, Any]],
+        cv: Optional[Dict[str, Any]],
+    ) -> Dict[str, Any]:
+        raise NotImplementedError

Implementation Steps:
1. Implement `_resolve_plan` to merge config defaults, dataclass values, and overrides (eta list, diagnostic toggles, CV feature list, output dir).
2. Rewrite batch/update preparation into `_prepare_batches` and `_compute_update_vector`, ensuring sample caching semantics remain unchanged.
3. Port existing ?H approx/true logic into `_maybe_compute_delta_h_approx` and `_maybe_compute_delta_h_true`, returning structured dicts keyed by diagnostics, swept ? values, and timing.
4. Integrate control-variates call inside `_maybe_run_control_variates`, reusing computed batches/update vector and permitting diagnostic-only runs.
5. Consolidate payload assembly (timing, precision, variance, curvature) and remove the old standalone CV runner; future scripts will construct an `ExperimentPlan` directly.
6. Update orchestration scripts (to be rewritten post-refactor) so they create plans rather than calling legacy entry points.

Config/Flags:
- Add `config['runner']['defaults']` for plan booleans (`compute_true`, `compute_linquad`, etc.) and optional `eta_list` overriding estimator-level settings.
- Support `config['runner']['diagnostics']` with modes `"minimal"`, `"standard"`, `"full"` controlling logging intensity.
- Preserve existing `approx_delta_h` and `control_variates` configs; allow runtime overrides to pass through `run_experiments`.

Validation:
- `python run_entropy_experiments_batch.py --config <colab-config> --mode full` (new script) should emit both ?H_true sweep and linear/lin+quad predictions matching prior outputs (within noise).
- `python run_entropy_experiments_batch.py --mode linear --eta 2e-5` should skip true evaluation but return approx diagnostics and histograms.
- `python run_entropy_experiments_batch.py --mode diagnostics` should emit control-variates artifacts without recomputing batches.
- Spot-check saved artifacts under `entropy_experiments/results/<run>` contain `batches`, `approx`, `true`, and `cv` sections.

Rollback:
- Restore `entropy_experiments/entropy_experiment_runner.py` to the previous commit and delete `ExperimentPlan` if unification needs to be abandoned.
- Remove new config keys if we revert to separate pathways.